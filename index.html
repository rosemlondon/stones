<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pulling down the stones</title>
    <!-- Load three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load 3d-force-graph -->
    <script src="https://unpkg.com/3d-force-graph"></script>
    <!-- Load three-spritetext -->
    <script src="https://unpkg.com/three-spritetext"></script>
    <link rel="stylesheet" type="text/css" href="3d-force-graph.css">
</head>
<style>
    body {
        margin: 0;
        height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: stretch;
    }
    #graph-container {
        flex: 1;
        position: relative;
    }
    .dataset-options {
        position: absolute;
        bottom: 40px;
        left: 10px;
        display: flex;
        flex-direction: column; /* Change this line */
        gap: 10px;
    }
    .dataset-option img {
        width: 100px;
        height: 100px;
        cursor: pointer;
    }
</style>
<body>
    <div id="3d-graph"></div>
    <button id="pause-btn">Pause</button>
    <button id="resume-btn">Resume</button>
    <div id="info-box">
        <div id="info-header"> Info</div>
        <div id="info-content">
            <p>Pulling down the stones is a walking journal and data visualisation experiment, mapping the landmarks of the Old Stones pilgrimage - a three-day walk through the main neolithic monuments across the peak district - onto a 3D force-directed node graph. </p>
            <p> This force-directed graph algorithm operates on the proximity of words and phrases ('tokens') within a sentence, and the shared repetition of those tokens within the text input. Forces then mimic attraction and repulsion to represent the strength of their connections, like roads between towns. This algorithm helps to visually organize and reveal the underlying structure of complex networks. </p>
            <p>Data scraped from web forums and my journal after completing this walk in April 2024. The desire was to see how the land looked mapped by writing, not topgraphy. </p>
            <p> Built using the JavaScript library Three.js. Best viewed on desktop. Click on a location on the left to change dataset to a different location on the walk. Pause and resume animation by buttons in top right. </p>        </div>
      </div>
    <div id="image-container">
        <img id="node-image" src="">
    </div>
    <!-- Dataset options in the bottom right corner -->
    <div class="dataset-options">
        <div class="dataset-option">
            <img src="images/arborlowdataset.png" alt="Arbor Low" title="Arbor Low" onclick="changeDataset('arbor_low.json')">
        </div>
        <div class="dataset-option">
            <img src="images/carlwarkdataset.jpg" alt="Carl Wark" title="Carl Wark" onclick="changeDataset('carl_wark.json')">
        </div>
        <div class="dataset-option">
            <img src="images/nineladies.jpg" alt="Nine Ladies" title="Nine Ladies" onclick="changeDataset('nine_ladies.json')">
        </div>
        <div class="dataset-option">
            <img src="images/minninglowhilldataset.png" alt="Minninglow Hill" title="Minninglow Hill" onclick="changeDataset('minninglow_dataset.json')">
        </div>
        <div class="dataset-option">
            <img src="images/arbor_hillshade.jpg" alt="Full Dataset" alt="Default Dataset" title="Back to Full Dataset" onclick="changeDataset('narrative.json')">
        </div>
    </div>
    <script src="info.js"></script>
    <script>
        let Graph;
        const imageContainer = document.getElementById('image-container');
        const nodeImage = document.getElementById('node-image');

        function initializeGraph(datasetUrl) {
            if (Graph) {
                Graph.graphData({ nodes: [], links: [] }); // Clear existing graph data
            }
            
            Graph = ForceGraph3D()(document.getElementById('3d-graph'))
                .jsonUrl(datasetUrl)
                .showNavInfo(false)
                .nodeThreeObject(node => {
                    const sprite = new SpriteText(node.id);
                    sprite.color = 'black';
                    sprite.textHeight = 8;
                    return sprite;
                })
                .linkLabel(link => link.id)
                .linkColor(() => 'black')
                .nodeColor(() => 'black')
                .backgroundColor('white')
                .onNodeClick(node => {
                    console.log('clicked node:', node);

                    const { nodes, links } = Graph.graphData();

                    // Toggle the hidden status of the node
                    node.__hidden = !node.__hidden;

                    // Update the visibility of the links connected to this node
                    links.forEach(link => {
                        if (link.source.id === node.id || link.target.id === node.id) {
                            link.__hidden = node.__hidden;
                        }
                    });

                    // Update the visibility of connected nodes
                    nodes.forEach(n => {
                        const isConnected = links.some(link => 
                            (link.source.id === node.id && link.target.id === n.id) || 
                            (link.target.id === node.id && link.source.id === n.id)
                        );
                        if (isConnected) {
                            n.__hidden = node.__hidden;
                        }
                    });

                    console.log('Updated nodes:', nodes);
                    console.log('Updated links:', links);

                    Graph.refresh();

                    // Display the node's image
                    if (node.image) {
                        nodeImage.src = node.image;
                        imageContainer.style.display = 'block';
                        imageContainer.appendChild(nodeImage);
                    } else {
                        imageContainer.style.display = 'none';
                    }
                })
                .onNodeRightClick(node => {
                    node.fx = node.fy = node.fz = null; // unfix node
                });

            // Auto-orbit
            let angle = 0;
            const distance = 300;
            let animationId;

            function animate() {
                animationId = requestAnimationFrame(animate);
                angle += 0.005;
                Graph.cameraPosition(
                    { x: distance * Math.sin(angle), y: distance * Math.cos(angle), z: distance }
                );
            }

            animate(); // start animation

            document.getElementById('pause-btn').addEventListener('click', () => {
                cancelAnimationFrame(animationId);
            });

            document.getElementById('resume-btn').addEventListener('click', () => {
                animate();
            });
        }

        function changeDataset(datasetName) {
            initializeGraph(`Datasets/${datasetName}`);
        }

        // Initial dataset
        changeDataset('narrative.json');
    </script>
    <div id="typing-container"></div>
    <script src="typingscript.js"></script>
</body>
</html>
